\documentclass[preprint]{sigplanconf}
%\documentclass[orivec,dvips,10pt]{llncs}

%\conferenceinfo{ICFP'10,} {September 27--29, 2010, Baltimore, Maryland, USA.}
%\CopyrightYear{2010}
%\copyrightdata{978-1-60558-794-3/10/09}

\usepackage[draft]{comments}
%\usepackage[final]{comments}
% \newcommand{\comment}[2]{[#1: #2]}
\newcommand{\khcomment}[1]{\comment{KH}{#1}}
\newcommand{\ebcomment}[1]{\comment{EB}{#1}}

\usepackage{epsfig}
\usepackage{path}
\usepackage{url}
\usepackage{amsmath,amssymb} 
\usepackage{fancyvrb}

\newenvironment{template}{\sffamily}

\usepackage{graphics,epsfig}
\usepackage{stmaryrd}

\input{./macros.ltx}
\input{./library.ltx}

\NatPackage
\FinPackage

\newcounter{per}
\setcounter{per}{1}

\newcommand{\Idris}{\textsc{Idris}}
\newcommand{\Eff}{\texttt{Effects}}

\newcommand{\pebox}[2]{\vspace*{0.1cm}\noindent
\begin{center}
\fbox{
\begin{minipage}{7.5cm}\textbf{#1:} #2\addtocounter{per}{1}
\end{minipage}}
\end{center}
\vspace*{0.1cm}
}

\newcommand{\perule}[1]{\vspace*{0.1cm}\noindent
\begin{center}
\fbox{
\begin{minipage}{7.5cm}\textbf{Rule \theper:} #1\addtocounter{per}{1}
\end{minipage}}
\end{center}
\vspace*{0.1cm}
}

\newcommand{\mysubsubsection}[1]{
\noindent
\textbf{#1}
}
\newcommand{\hdecl}[1]{\texttt{#1}}

\begin{document}

\title{Programming and Reasoning with Algebraic Effects}
\subtitle{Or: $\Pi$, the Ultimate Monad Transformer}
\authorinfo{Edwin C. Brady}
{School of Computer Science, 
University of St Andrews, St Andrews, Scotland.}
{Email: ecb10@st-andrews.ac.uk}

\maketitle

\begin{abstract}
One often cited benefit of pure functional programming is that pure code is
easier to test and reason about, both formally and informally. However, in
order to be useful, programs must interact with the outside world in some way
--- real programs have state, open files, send data over a network, draw
pictures, and so on. Haskell solves this problem using \remph{monads} to capture
details of possibly side effecting computations --- it provides monads for
capturing State, I/O, exceptions, non-determinism, libraries for practical
purposes such as CGI and parsing, and many others, as well as \remph{monad
transformers} for combining multiple effects.

Unfortunately, useful as monads are, they do not compose very well. Monad
transformers can quickly become unwieldy when there are lots of effects to
manage, leading to a temptation in larger programs to combine everything into
one coarse-grained state and exception monad. In this paper I describe an
alternative approach based on handling ~\remph{algebraic effects}, implemented
in the Idris programming language. I show how to describe side effecting
computations, how to write programs which compose multiple fine-grained
effects, and how, using dependent types, we can use this approach to reason
about states in effectful programs.
\end{abstract}

%\category{D.3.2}{Programming Languages}{Language
%  Classifications}[Applicative (functional) Languages]
%\category{D.3.4}{Programming Languages}{Processors}[Compilers]
%\terms{Languages, Verification, Performance}
%\keywords{Dependent Types, Partial Evaluation}

\input{intro}

\input{idrisintro}

\input{effectsfp}

%\input{algeffects}

\input{effdsl}

\input{effimpl}

\input{appdesign}

\input{conclusions}

%\section*{Acknowledgments}

%This work was partly funded by the Scottish Informatics and Computer
%Science Alliance (SICSA), by EU Framework 7 Project
%No. 248828 (ADVANCE) and by EPSRC grant EP/F030657 (Islay).
%We thank our colleagues, notably William Cook, James McKinna and Anil Madhavapeddy for several helpful
%discussions, and the anonymous reviewers for their constructive suggestions on this paper.

\bibliographystyle{abbrv}
\begin{small}
\bibliography{library}

\appendix
%\input{code}

\end{small}
\end{document}
