\section{Motivating Example: An Effectful Evaluator}

Let us begin by writing an evaluator for an evaluator for a simple expression
language, in \Idris{}. 
%We will introduce \Idris{} and its specific features in
%more depth in Section \ref{sect:idris}. For now, it suffices to know that
%\Idris{} syntax is based heavily on Haskell, with the exception that a 
%single colon is used for a type declaration and a double colon for list
%construction, emphasising the importance of types.
To keep the language as simple as possible, we will limit expressions
to integer values, and addition. In \Idris{}, we can represent expressions
as follows:

\begin{SaveVerbatim}{exprlang1}

data Expr = Val Int 
          | Add Expr Expr

\end{SaveVerbatim}
\useverb{exprlang1}

\noindent
Evaluating these expressions is straightforward, by traversing the expression
tree:

\begin{SaveVerbatim}{expreval1}

eval : Expr -> Int
eval (Val i) = i
eval (Add x y) = eval x + eval y

\end{SaveVerbatim}
\useverb{expreval1}

\noindent
However, for a realistic language we will need to add more features, such
as variables or user interaction, which require handling effects such as
exceptions (in the case of undefined variables) or state.

\subsection{An Effectful Evaluator}

\label{sect:naiveeval}

Let us briefly explore a na\"{i}ve implementation of an
evaluator for an expression language like the above, augmented with
variables, error checking and random numbers.

\subsubsection{Adding variables}

\begin{SaveVerbatim}{exprlang2}

data Expr = Val Int
          | Var String
          | Add Expr Expr

\end{SaveVerbatim}
\useverb{exprlang2}

To add variables, we introduce a state monad for threading an environment
through an evaluation.

\begin{SaveVerbatim}{evalstate}

Env : Type
Env = List (String, Int)

data Eval a = MkEval (Env -> (a, Env))

instance Monad Eval where
    ...

\end{SaveVerbatim}
\useverb{evalstate}

To access and update the environment, we need to provide primitives for
manipulating the state:

\begin{SaveVerbatim}{getputeval}

get : Eval Env
get = MkEval (\env => (env, env))
  
put : Env -> Eval ()
put env = MkEval (\x => ((), env))

\end{SaveVerbatim}
\useverb{getputeval}

\begin{SaveVerbatim}{expreval2}

eval : Expr -> Eval Int
eval (Val i) = return i
eval (Var x) = do env <- get
                  case lookup x env of
                       Just i => return i
eval (Add x y) = do x' <- eval x 
                    y' <- eval y
                    return (x' + y')

runEval : List (String, Int) -> Expr -> Int
runEval env expr = case eval expr of
                        MkEval f => do res <- f env
                                       return res

\end{SaveVerbatim}
\useverb{expreval2}

\noindent
\textbf{Aside:} \Idris{} supports idiom brackets~\cite{McBride2007} for a
more concise notation for programming with applicative functors (all monads
in \Idris{} are also applicative functions) which means the \texttt{Add}
case can be written as follows:

\begin{SaveVerbatim}{expridiom}

eval (Add x y) = [| eval x + eval y |]

\end{SaveVerbatim}
\useverb{expridiom}

\noindent
An application inside idiom brackets, \texttt{[| f a b c d |]} translates
directly to:

\begin{SaveVerbatim}{idiomtrans}

pure f <$> a <$> b <$> c <$> d

\end{SaveVerbatim}
\useverb{idiomtrans}

\subsubsection{Adding error checking}

\begin{SaveVerbatim}{evalmonad3}

data Eval a = MkEval (Env -> Maybe (a, Env))

lift : Maybe a -> Eval a

\end{SaveVerbatim}
\useverb{evalmonad3}

We need to modify \texttt{get} and \texttt{put} to inject a value into the
\texttt{Maybe} monad:

\begin{SaveVerbatim}{getput3}

get : Eval EvalState
get = MkEval (\env => Just (env, env))
  
put : EvalState -> Eval ()
put env = MkEval (\x => Just ((), env))

\end{SaveVerbatim}
\useverb{getput3}

\begin{SaveVerbatim}{expreval3}

eval : Expr -> Eval Int
eval (Val i) = return i
eval (Var x) = do env <- get
                  lift (lookup x env)
eval (Add x y) = [| eval x + eval y |]

\end{SaveVerbatim}
\useverb{expreval3}

\begin{SaveVerbatim}{runeval3}

runEval : List (String, Int) -> Expr -> Maybe Int
runEval env expr = case eval expr of
                        MkEval f => do (res, _) <- f env
                                       return res

\end{SaveVerbatim}
\useverb{runeval3}

\subsubsection{Adding random number generation}

\begin{SaveVerbatim}{exprlang4}

data Expr = Val Int
          | Var String
          | Add Expr Expr
          | Random Int

\end{SaveVerbatim}
\useverb{exprlang4}

We extend the evaluator state to include a random number seed as well as
the environment:

\begin{SaveVerbatim}{evalmonad4}

EvalState : Type
EvalState = (Int, List (String, Int))
  
data Eval a = MkEval (EvalState -> Maybe (a, EvalState))

\end{SaveVerbatim}
\useverb{evalmonad4}

Then, we can implement random number generation by extracting the appropriate
part of the state, calculating a number (here using a simple linear congruence
generator) the updating the seed:

\begin{SaveVerbatim}{rndint}

rndInt : Int -> Int -> Eval Int
rndInt lower upper 
    = do (seed, env) <- get
         let seed' = 1664525 * seed + 1013904223
         put (seed', env)
         return (seed `mod` (upper - lower) + lower)

\end{SaveVerbatim}
\useverb{rndint}

We need to modify the evaluator so that we extract the appropriate parts
of the state:

\begin{SaveVerbatim}{expreval4}

eval : Expr -> Eval Int
eval (Val i) = return i
eval (Var x) = do (seed, env) <- get
                  lift (lookup x env)
eval (Add x y) = [| eval x + eval y |]
eval (Random upper) = do val <- rndInt 0 upper
                         return val

\end{SaveVerbatim}
\useverb{expreval4}

Every time we add an effect, we have to update the monad and update any
code which manages the state. There are various ways we could improve this
--- for example implementing the state as a record and abstracting away
updates and queries --- but we have a more fundamental problem that the
effects we have added are neither \remph{composable} nor easily
\remph{reusable}, nor can we easily write subprograms which use a 
restricted subset of the effects.

\subsection{The Haskell approach: Monad transformers}

\begin{SaveVerbatim}{evalhs}

eval :: RandomGen g => 
        Expr -> RandT g (ReaderT Env Maybe) Int
eval (Val n) = return n
eval (Var x) = do env <- lift ask
                  lift (lift (lookup x env))
eval (Add x y) = pure (+) <*> eval x <*> eval y
eval (Random x) = do val <- getRandomR (0, x)
                     return val

\end{SaveVerbatim}
\useverb{evalhs}

Still problems: composability, noise of \texttt{lift} (though can be mitigated
by making type class versions, e.g. MonadReader class), still hard to call
a subset of effects, leads to tendency to return to an approach like
Section \ref{sect:naiveeval}, with minimal use of transformers.

\subsection{Can we do better?}

