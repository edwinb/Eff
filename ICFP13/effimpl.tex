\section{The \Eff{} DSL implementation}

\begin{SaveVerbatim}{effdslstruct}
data EffM : (m : Type -> Type) -> List EFFECT -> List EFFECT -> Type -> Type where
     value   : a -> EffM m xs xs a
     (>>=)   : EffM m xs xs' a -> (a -> EffM m xs' xs'' b) -> EffM m xs xs'' b
     effectP : (prf : EffElem e a xs) -> (eff : e a b t) -> EffM m xs (updateResTy xs prf eff) t
     liftP   : (prf : SubList ys xs) -> EffM m ys ys' t -> EffM m xs (updateWith ys' xs prf) t
     (:-)    : (l : ty) -> EffM m [x] [y] t -> EffM m [l ::: x] [l ::: y] t
     new     : Handler e m => res -> EffM m (MkEff res e :: xs) (MkEff res' e :: xs') a -> EffM m xs xs' a
     catch   : Catchable m err => EffM m xs xs' a -> (err -> EffM m xs xs' a) -> EffM m xs xs' a
\end{SaveVerbatim}

\begin{figure*}[t]
\begin{center}
\useverb{effdslstruct}
\end{center}
\caption{The \Eff{} DSL data type}
\label{effdsltype}
\end{figure*}

\subsection{Language representation}

The \Eff{} langued is implemented as a syntax tree \texttt{EffM}
plus a tagless interpreter, where the
types in the syntax tree ensure that all \Eff{} programs are well typed.
The language itself as parameterised over its computation context \texttt{m},
and indexed by the list of effects on input and the list of effects on output,
as well as the return type of the computation:

\begin{SaveVerbatim}{effty}

EffM : (m : Type -> Type) -> 
       List EFFECT -> List EFFECT -> Type -> Type

\end{SaveVerbatim}
\useverb{effty}

\noindent
For the common case of programs in which the input effects are the same as
the output effects, we define \texttt{Eff}:

\begin{SaveVerbatim}{effimmutable}

Eff : (Type -> Type) -> List EFFECT -> Type -> Type
Eff m xs t = EffM m xs xs t

\end{SaveVerbatim}
\useverb{effimmutable}

\noindent
The complete syntax is given in Figure \ref{effdsltype} for reference. In this
section, we describe the constructs in detail.

\subsubsection{Basic constructs}

In the simplest case, we would like to inject pure values into the
\texttt{EffM} representation:

\begin{SaveVerbatim}{effval}

value : a -> EffM m xs xs a

\end{SaveVerbatim}
\useverb{effval}

We have \texttt{(>==)} to support \texttt{do} notation:

\begin{SaveVerbatim}{effbind}

(>>=) : EffM m xs xs' a -> 
        (a -> EffM m xs' xs'' b) -> EffM m xs xs'' b

\end{SaveVerbatim}
\useverb{effbind}

\subsubsection{Invoking effects}

\subsubsection*{Directly invoking effects}

\begin{SaveVerbatim}{effinvoke}

effectP : (prf : EffElem e a xs) -> (eff : e a b t) -> 
          EffM m xs (updateResTy xs prf eff) t

\end{SaveVerbatim}
\useverb{effinvoke}

\begin{SaveVerbatim}{}

updateResTy : (xs : List EFFECT) -> 
              EffElem e a xs -> e a b t -> List EFFECT
updateResTy {b} (MkEff a e :: xs) Here      n 
                 = (MkEff b e) :: xs
updateResTy     (x :: xs)         (There p) n 
                 = x :: updateResTy xs p n

\end{SaveVerbatim}
\useverb{}

\begin{SaveVerbatim}{effelem}

data EffElem : (Type -> Type -> Type -> Type) -> 
               Type -> List EFFECT -> Type where
     Here : EffElem x a (MkEff a x :: xs)
     There : EffElem x a xs -> EffElem x a (y :: xs)

\end{SaveVerbatim}
\useverb{effelem}

\Idris{} currently has very limited proof search capabilities, but they
are sufficient for constructing proofs of \texttt{EffElem x xs} automatically.
If a list is statically known, we can find a proof
by a brute force search, if \texttt{x} is an available effect. If not, we limit
the search depth:

\begin{SaveVerbatim}{findeff}

findEffElem : Nat -> Tactic 
findEffElem O = Refine "Here" `Seq` Solve 
findEffElem (S n) = GoalType "EffElem" 
      (Try (Refine "Here" `Seq` Solve)
           (Refine "There" `Seq` 
                   (Solve `Seq` findEffElem n)))

\end{SaveVerbatim}
\useverb{findeff}

\noindent
This could be improved with a simple reflection mechanism to allow the proof
search to inspect the goal --- this will be added in a future version of \Idris{}.
In practice, we have found the brute force approach to be adequate. Once we
have proof search, we can use the default implicit argument mechanism to
invoke proof search automatically:

\begin{SaveVerbatim}{impeff}

effect : {default tactics { 
                     reflect findEffElem 100; 
                     solve; 
                  } 
            prf : EffElem e a xs} -> 
         (eff : e a b t) -> 
         EffM m xs (updateResTy xs prf eff) t
effect {prf} e = effectP prf e

\end{SaveVerbatim}
\useverb{impeff}

\subsubsection*{Effectful subprograms}

\begin{SaveVerbatim}{efflift}

lift : (prf : SubList ys xs) ->
       EffM m ys ys' t -> 
       EffM m xs (updateWith ys' xs prf) t

\end{SaveVerbatim}
\useverb{efflift}

\begin{SaveVerbatim}{sublist}

data SubList : List a -> List a -> Type where
     SubNil : SubList [] []
     Keep   : SubList xs ys -> 
              SubList (x :: xs) (x :: ys)
     Drop   : SubList xs ys -> 
              SubList xs (x :: ys)

\end{SaveVerbatim}
\useverb{sublist}

\begin{SaveVerbatim}{updwith}

updateWith : (ys' : List a) -> (xs : List a) ->
             SubList ys xs -> List a
updateWith (y :: ys) (x :: xs) (Keep rest) 
           = y :: updateWith ys xs rest
updateWith ys        (x :: xs) (Drop rest) 
           = x :: updateWith ys xs rest
updateWith []        []        SubNil      
           = []

\end{SaveVerbatim}
\useverb{updwith}

\subsubsection{Labelling effects}

If we have an effectful program \texttt{p} with a single effect, we can 
\remph{label} that effect using the \texttt{(:-)} operator:

\begin{SaveVerbatim}{lblintro}

(:-)  : (l : ty) -> 
        EffM m [x] [y] t -> 
        EffM m [l ::: x] [l ::: y] t

\end{SaveVerbatim}
\useverb{lblintro}

[Example here]

\subsubsection{Introducing effects}

We can introduce a new effect in the course of an effectful program, provided
that the effect can be handled in the current computation context \texttt{m}:

\begin{SaveVerbatim}{neweff}

new : Handler e m => res -> 
      EffM m (MkEff res e :: xs) 
             (MkEff res' e :: xs') a ->
      EffM m xs xs' a

\end{SaveVerbatim}
\useverb{neweff}

\noindent
Once the subprogram is complete, the resource for the new effect is discarded,
as is clear from the type of \texttt{new}.

[Example here]

\subsubsection{Handling failure}

Finally, if the computation context \texttt{m} supports failure handling,
we can use the \texttt{catch} construct to handle errors:

\begin{SaveVerbatim}{catcheff}

catch : Catchable m err =>
        EffM m xs xs' a -> (err -> EffM m xs xs' a) ->
        EffM m xs xs' a

\end{SaveVerbatim}
\useverb{catcheff}


\subsection{The \Eff{} interpreter}

\begin{SaveVerbatim}{effdslinterp}
eff : Env m xs -> EffM m xs xs' a -> (Env m xs' -> a -> m b) -> m b
eff env (value x) k = k env x
eff env (prog `ebind` c) k = eff env prog (\env', p' => eff env' (c p') k)
eff env (effect prf effP) k = execEff env prf effP k
eff env (lift prf effP) k = let env' = dropEnv env prf in 
                                eff env' effP (\envk, p' => k (rebuildEnv envk prf env) p')
eff env (new r prog) k = let env' = r :: env in 
                             eff env' prog (\ (v :: envk), p' => k envk p')
eff env (catch prog handler) k = catch (eff env prog k)
                                       (\e => eff env (handler e) k)
eff {xs = [l ::: x]} env (l :- prog) k = let env' = unlabel {l} env in
                                             eff env' prog (\envk, p' => k (relabel l envk) p')
\end{SaveVerbatim}

\begin{figure*}[t]
\begin{center}
\useverb{effdslinterp}
\end{center}
\caption{The \Eff{} DSL interpreter}
\label{effdsltype}
\end{figure*}


\begin{SaveVerbatim}{resenv}

data Env  : (m : Type -> Type) -> 
            List EFFECT -> Type where
     Nil  : Env m Nil
     (::) : Handler eff m => 
            a -> Env m xs -> Env m (MkEff a eff :: xs)

\end{SaveVerbatim}
\label{sect:envdef}
\useverb{resenv}

\begin{SaveVerbatim}{invokehandler}

execEff : Env m xs -> (p : EffElem e res xs) -> 
          (eff : e res b a) ->
          (Env m (updateResTy xs p eff) -> a -> m t) -> 
          m t
execEff (val :: env) Here eff' k 
    = handle val eff' (\res, v => k (res :: env) v)
execEff (val :: env) (There p) eff k 
    = execEff env p eff (\env', v => k (val :: env') v)

\end{SaveVerbatim}
\useverb{invokehandler}

\begin{SaveVerbatim}{cpsinterp}

eff : Env m xs -> EffM m xs xs' a -> 
      (Env m xs' -> a -> m b) -> m b

\end{SaveVerbatim}
\useverb{cpsinterp}

\begin{SaveVerbatim}{runeff}

run : Applicative m => 
      Env m xs -> EffM m xs xs' a -> m a
run env prog = eff env prog (\env, r => pure r)

runPure : Env id xs -> EffM id xs xs' a -> a
runPure env prog = eff env prog (\env, r => r)

\end{SaveVerbatim}
\useverb{runeff}

